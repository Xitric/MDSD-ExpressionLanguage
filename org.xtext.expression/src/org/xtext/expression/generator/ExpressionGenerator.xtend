/*
 * generated by Xtext 2.20.0
 */
package org.xtext.expression.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.expression.expression.Binary
import org.xtext.expression.expression.Div
import org.xtext.expression.expression.Functional
import org.xtext.expression.expression.MathExpression
import org.xtext.expression.expression.Minus
import org.xtext.expression.expression.Mult
import org.xtext.expression.expression.Number
import org.xtext.expression.expression.Parenthesis
import org.xtext.expression.expression.Plus
import org.xtext.expression.expression.Reference
import org.xtext.expression.expression.Variable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ExpressionGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExpression).next
		System.out.println('''«math.display» = «math.compute»''')
	}
	
	//
	// Compute
	//
	def int compute(MathExpression math) {
		math.expression.computeExp
	}
	
	def dispatch int computeExp(Binary binary) {
		val left = binary.left.computeExp
		switch binary.operator {
			Plus: left + binary.right.computeExp
			Minus: left - binary.right.computeExp
			Mult: left * binary.right.computeExp
			Div: left / binary.right.computeExp
			default: throw new IllegalArgumentException('''Unexpected operator «binary.operator.class.name»''')
		}
	}
	
	def dispatch int computeExp(Functional functional) {
		//TODO: Scoping
		functional.expression.computeExp
	}
	
	def dispatch int computeExp(Number number) {
		number.value
	}
	
	def dispatch int computeExp(Parenthesis parenthesis) {
		parenthesis.expression.computeExp
	}
	
	def dispatch int computeExp(Reference reference) {
		reference.variable.computeVar
	}
	
	def int computeVar(Variable variable) {
		//TODO: Scoping
		variable.expression.computeExp
	}
	
	//
	// Display
	//
	//TODO: Scoping
	def CharSequence display(MathExpression math) '''«math.definitions.map[displayDef].join(" ")» «math.expression.displayExp»'''
	
	def dispatch CharSequence displayExp(Binary binary) '''«binary.left.displayExp» «binary.operator.displayOp» «binary.right.displayExp»'''
	def dispatch CharSequence displayExp(Parenthesis parenthesis) '''(«parenthesis.expression.displayExp»)'''
	def dispatch CharSequence displayExp(Number num) '''«num.value»'''
	def dispatch CharSequence displayExp(Functional functional) '''let «functional.variable.displayVar» in «functional.expression.displayExp» end'''
	def dispatch CharSequence displayExp(Reference reference) '''«reference.variable.name»'''
	
	def CharSequence displayDef(Variable variable) '''def «variable.displayVar» with'''
	def CharSequence displayVar(Variable variable) '''«variable.name» = «variable.expression.displayExp»'''
	
	def dispatch CharSequence displayOp(Plus op) '''+'''
	def dispatch CharSequence displayOp(Minus op) '''-'''
	def dispatch CharSequence displayOp(Mult op) '''*'''
	def dispatch CharSequence displayOp(Div op) '''/'''
}
